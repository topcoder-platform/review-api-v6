// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model scorecard {
  id             String          @id @default(dbgenerated("nanoid()")) @db.VarChar(14)   # Primary key with auto-generation using nanoid()
  legacyId       String?         # Optional unique identifier from legacy system
  status         ScorecardStatus # Enum: ACTIVE, INACTIVE, DELETED (for overall scorecard status)
  type           ScorecardType  # Enum: SCREENING, REVIEW, APPROVAL, POST_MORTEM, etc. for scorecard purpose
  challengeTrack ChallengeTrack   # Enum: DEVELOPMENT, DATA_SCIENCE, DESIGN, QUALITY_ASSURANCE tracking challenge domain
  challengeType  String?          # Optional field specifying type of challenge (e.g., 'coding', 'design')
  name           String          # Display name of the scorecard
  version        String          # Version identifier for the scorecard template
  minScore       Float           # Minimum possible score value for this scorecard
  maxScore       Float?           # Optional maximum possible score value (if not set, use defaults)
  createdAt      DateTime         @default(now())   # Timestamp of creation
  createdBy      String          # ID or handle of user who created the scorecard
  updatedAt       DateTime        # Timestamp for last update
  updatedBy      String          # User ID or handle making changes

  // Indexes for faster searches
  @@index([challengeTrack])    # Index on challenge track enum for filtering by domain
  @@index([challengeType])     # Index on optional challenge type field (if present, enables fast lookups)
  @@index([name])               # Index on display name to improve search performance

  // Additional indexes specific to relationships and common queries:
  @@index([id])                 # Standard index for direct ID lookups
  @@index([type])               # Index for filtering by scorecard type (e.g., 'REVIEW')
  @@index([status])             # Index for efficient status-based filtering

  // Relations: a scorecard can have multiple groups and reviews
  scorecardGroups scorecardGroup[]   # One-to-many relation with scorecardGroup model
  reviews         review[]          # One-to-many relation with review model (each review belongs to one scorecard)

}

enum ScorecardStatus {
  ACTIVE
  INACTIVE
  DELETED
}

enum ScorecardType {
  SCREENING
  REVIEW
  APPROVAL
  POST_MORTEM
  SPECIFICATION_REVIEW
  CHECKPOINT_SCREENING
  CHECKPOINT_REVIEW
  ITERATIVE_REVIEW
}

enum ChallengeTrack {
  DEVELOPMENT
  DATA_SCIENCE
  DESIGN
  QUALITY_ASSURANCE
}

model scorecardGroup {
  id          String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)         # Auto-generated ID using nanoid()
  legacyId    String?                                              # Optional historical identifier
  scorecardId String                                                    # References the parent scorecard's ID (one-to-one relation)
  name        String                                                 # Name of this group within a scorecard
  weight      Float                                                  # Weightage assigned to this group in percentage terms
  sortOrder   Int                                                    # Order position for sorting sections/ questions
  createdAt   DateTime @default(now())                             # Timestamp when record was created
  createdBy    String                                                # User who created this scorecard group
  updatedAt    DateTime                                               # Automatic timestamp on each update
  updatedBy    String                                                 # User making the most recent change

  // Relation with parent scorecard (using nanoid() for unique ID)
  scorecardId: String   @unique   # Unique constraint to maintain relation integrity
  scorecard scorecard          @relation(fields: [scorecardId], references: [id], onDelete: Cascade)

  // Child relations:
  sections  scorecardSection[]

  // Indexes and search optimizations:
  @@index([id])                 # Standard index for direct ID lookups
  @@index([scorecardId])        # Index to join with parent scorecard model efficiently
  @@index([sortOrder])          # Index for ordering groups (e.g., by creation time or manual order)

}

model scorecardSection {
  id               String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId         String?
  scorecardGroupId String
  name             String
  weight           Float
  sortOrder        Int
  createdAt        DateTime @default(now())
  createdBy        String
  updatedAt        DateTime @updatedAt
  updatedBy        String

  group     scorecardGroup      @relation(fields: [scorecardGroupId], references: [id], onDelete: Cascade)
  questions scorecardQuestion[]

  @@index([id]) // Index for direct ID lookups
  @@index([scorecardGroupId]) // Index for joining with scorecardGroup table
  @@index([sortOrder]) // Index for ordering sections
}

enum QuestionType {
  SCALE
  YES_NO
  TEST_CASE
  // Add other types as needed
}

model scorecardQuestion {
  id                 String       @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId           String?
  scorecardSectionId String
  type               QuestionType
  description        String
  guidelines         String
  weight             Float
  requiresUpload     Boolean
  sortOrder          Int
  createdAt          DateTime     @default(now())
  createdBy          String
  updatedAt          DateTime     @updatedAt
  updatedBy          String

  scaleMin Int? // Minimum value for scale (used when type is SCALE)
  scaleMax Int? // Maximum value for scale (used when type is SCALE)

  section scorecardSection @relation(fields: [scorecardSectionId], references: [id], onDelete: Cascade)

  @@index([id]) // Index for direct ID lookups
  @@index([scorecardSectionId]) // Index for joining with scorecardSection table
  @@index([type]) // Index for filtering questions by type
  @@index([sortOrder]) // Index for ordering questions
}

model review {
  id           String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId     String?
  resourceId   String
  phaseId      String
  submissionId String
  scorecardId  String
  committed    Boolean  @default(false)
  finalScore   Float
  initialScore Float
  createdAt    DateTime @default(now())
  createdBy    String
  updatedAt    DateTime @updatedAt
  updatedBy    String

  scorecard   scorecard    @relation(fields: [scorecardId], references: [id], onDelete: Cascade)
  reviewItems reviewItem[]

  @@index([committed]) // Index for filtering by committed status
  @@index([submissionId]) // Index for filtering by submission
  @@index([resourceId]) // Index for filtering by resource (reviewer)
  @@index([id]) // Index for direct ID lookups
  @@index([phaseId]) // Index for filtering by phase
  @@index([scorecardId]) // Index for joining with scorecard table
}

model reviewItem {
  id                  String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId            String?
  reviewId            String
  scorecardQuestionId String
  uploadId            String?
  initialAnswer       String
  finalAnswer         String?
  managerComment      String?
  createdAt           DateTime @default(now())
  createdBy           String
  updatedAt           DateTime @updatedAt
  updatedBy           String

  review             review              @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reviewItemComments reviewItemComment[]
  @@index([reviewId]) // Index for joining with review table
  @@index([id]) // Index for direct ID lookups
  @@index([scorecardQuestionId]) // Index for joining with scorecardQuestion table
}

model reviewItemComment {
  id           String                @id @default(dbgenerated("nanoid()")) @db.VarChar(14) # Auto-generated ID using nanoid()
  legacyId     String?                             # Optional historical identifier (from previous systems)
  resourceId   String                               # User or resource who authored the comment
  reviewItemId String                                # Links to specific review item being commented on
  content      String                              # Actual text/content of the comment
  type         ReviewItemCommentType                 # Enum indicating the nature/role of this comment (e.g., 'COMMENT', 'REQUIRED')
  sortOrder    Int                                    # Default:0; used for ordering comments in UI display
  
  // Timestamps:
  createdAt    DateTime @default(now())              # Automatic creation timestamp
  createdBy     String                               # User who created this review item comment
  updatedAt     DateTime                             # Automatic update timestamp on each change
  updatedBy      String                              # User making the most recent modification

  // Relations to other models:
  reviewItemCommentId: String @unique                # Unique constraint for relation mapping
  
  reviewItem reviewItem @relation(fields: [reviewItemId], references: [id])   # Relation to specific review item (one-to-one)
  
  // Optional relations:
  appeal     appeal?          # One-to-zero-or-one relation with an appeal comment
  
  // Indexes for search and filtering performance:
  @@index([reviewItemId])      # Optimizes joins and queries by review item ID
  @@index([id])                 # Standard index for direct lookups by ID
  @@index([resourceId])         # Enables faster queries by resource (commenter) or user
  
}

enum ReviewItemCommentType {
  COMMENT
  REQUIRED
  RECOMMENDED
  AGGREGATION_COMMENT
  AGGREGATION_REVIEW_COMMENT
  SUBMITTER_COMMENT
  FINAL_FIX_COMMENT
  FINAL_REVIEW_COMMENT
  MANAGER_COMMENT
  APPROVAL_REVIEW_COMMENT
  APPROVAL_REVIEW_COMMENT_OTHER_FIXES
  SPECIFICATION_REVIEW_COMMENT
}

model appeal {
  id                  String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId            String?
  resourceId          String
  reviewItemCommentId String   @unique // Ensure one-to-one relationship
  content             String
  createdAt           DateTime @default(now())
  createdBy           String
  updatedAt           DateTime @updatedAt
  updatedBy           String

  reviewItemComment reviewItemComment @relation(fields: [reviewItemCommentId], references: [id], onDelete: Cascade) // Define fields and references here
  appealResponse    appealResponse?

  @@index([resourceId]) // Index for resource ID
  @@index([id]) // Index for direct ID lookups
  @@index([reviewItemCommentId]) // Index for joining with reviewItemComment table
}

model appealResponse {
  id         String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  legacyId   String?
  appealId   String   @unique
  resourceId String
  content    String
  success    Boolean
  createdAt  DateTime @default(now())
  createdBy  String
  updatedAt  DateTime @updatedAt
  updatedBy  String

  appeal appeal @relation(fields: [appealId], references: [id], onDelete: Cascade)

  @@index([id]) // Index for direct ID lookups
  @@index([appealId]) // Index for joining with appeal table
  @@index([resourceId]) // Index for filtering by resource (responder)
}

model challengeResult {
  challengeId     String
  userId          String
  paymentId       String?
  submissionId    String
  oldRating       Int?
  newRating       Int?
  initialScore    Float
  finalScore      Float
  placement       Int
  rated           Boolean
  passedReview    Boolean
  validSubmission Boolean
  pointAdjustment Float?
  ratingOrder     Int?

  createdAt DateTime @default(now())
  createdBy String
  updatedAt DateTime @updatedAt
  updatedBy String

  @@id([challengeId, userId])
  @@index([challengeId]) // Index for filtering by challenge
  @@index([userId]) // Index for filtering by user
  @@index([submissionId]) // Index for filtering by submission
}

model contactRequest {
  id          String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  resourceId  String
  challengeId String // Associated challenge
  message     String // Markdown content
  createdAt   DateTime @default(now())
  createdBy   String
  updatedAt   DateTime @updatedAt
  updatedBy   String

  @@index([id]) // Index for direct ID lookups
  @@index([resourceId]) // Index for filtering by resource (requester)
  @@index([challengeId]) // Index for filtering by challenge
}

enum ReviewOpportunityStatus {
  OPEN
  CLOSED
  CANCELLED
}

enum ReviewApplicationStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum ReviewOpportunityType {
  REGULAR_REVIEW
  COMPONENT_DEV_REVIEW
  SPEC_REVIEW
  ITERATIVE_REVIEW
  SCENARIOS_REVIEW
}

enum ReviewApplicationRole {
  PRIMARY_REVIEWER
  SECONDARY_REVIEWER
  PRIMARY_FAILURE_REVIEWER
  ACCURACY_REVIEWER
  STRESS_REVIEWER
  FAILURE_REVIEWER
  SPECIFICATION_REVIEWER
  ITERATIVE_REVIEWER
  REVIEWER
}

model reviewOpportunity {
  id          String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  challengeId String
  status      ReviewOpportunityStatus
  type        ReviewOpportunityType
  openPositions Int
  startDate   DateTime
  duration    Int
  basePayment Float
  incrementalPayment  Float

  applications reviewApplication[]

  createdAt   DateTime @default(now())
  createdBy   String
  updatedAt   DateTime @updatedAt
  updatedBy   String

  @@unique([challengeId, type])

  @@index([id]) // Index for direct ID lookups
  @@index([challengeId]) // Index for filtering by challenge
}


model reviewApplication {
  id          String   @id @default(dbgenerated("nanoid()")) @db.VarChar(14)
  userId      String
  handle      String
  opportunityId String
  role        ReviewApplicationRole
  status      ReviewApplicationStatus

  opportunity reviewOpportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  createdBy   String
  updatedAt   DateTime @updatedAt
  updatedBy   String

  @@unique([opportunityId, userId, role])

  @@index([id]) // Index for direct ID lookups
  @@index([userId])
  @@index([opportunityId])
}
